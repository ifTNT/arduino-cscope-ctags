#!/bin/python3

"""
arduino-cscope-ctags, generating database of cscope/ctags from Arduino sketch for code tracing.
Copyright (C) 2021 Yung-Hsiang Hu

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

Contact:
Yung-Hsiang Hu <iftnt1999 [at] gmail.com>

"""

import subprocess
import sys
import json
from pathlib import Path
import re
import itertools
import argparse

# The location to storage intermediate data
build_temp_dir = Path("/tmp/arduino-cscope-ctags")

# Helper function to get the string of absolute path from path object
def get_abs_path(path):
  return str(Path(path).absolute())

# Helper function to extract header files from given include path
def get_header_list(path):
  target_file_regex = "*.[h|hpp]"
  files = list(Path(path).rglob(target_file_regex))
  return [get_abs_path(path) for path in files]

def main(board_fqbn, sketch_path, db_output_path):
  # Ensure sketch_path is a path object
  sketch_path = Path(sketch_path)
  # The path of compile commands file generated by arduino-cli
  compile_command_path= build_temp_dir/"compile_commands.json"
  # The intermediate file that storages the list of included files
  including_list_path = build_temp_dir/"includes.list"
  # The target path of tag databases
  database_path = sketch_path/db_output_path
  cscope_database_path = database_path/"cscope.out"
  ctags_database_path = database_path/"ctags"

  # Prepare the working directory
  build_temp_dir.mkdir(parents=True, exist_ok=True)
  database_path.mkdir(parents=True, exist_ok=True)
  
  print(f"Generating including path from sketch {sketch_path}")
  
  # Run arduino-cli to generate the compile commands
  try:
    arduino_cli = subprocess.run([
      "arduino-cli",
      "compile",
      "--verbose",         # Display more information to user
      "--clean",           # Prevent using cache to obtain full list of source files
      "--output-dir",      # The place to store build artifacts
      str(build_temp_dir),
      "--build-path",      # The loaction where the compiled file will be placed
      str(build_temp_dir),
      "--fqbn",            # The full-name of the board. Can be obtained via `board listall`
      board_fqbn,
      str(sketch_path)
    ], stderr=subprocess.PIPE)
    arduino_cli.check_returncode()
  except subprocess.CalledProcessError as e:
    print ( "Error in executing arduino-cli:\nreturn code: ", e.returncode, "\nOutput: ", e.stderr.decode("utf-8") )
    raise

  print(f"Collecting list of included files to {database_path}")

  # The file paths that will be passed to cscope/ctags
  # Use set to prevent duplicated path element
  included_files=set()

  # Open the compile command file in the safe way
  try:
    compile_command_file = open(compile_command_path, 'r')
  except OSError:
      print(f"Could not open file: {compile_command_path}\nPlease make sure the file is existed")
      sys.exit()

  # Fetch compile commands generated by arduino-cli from file
  with compile_command_file:
    compile_entities = json.load(compile_command_file)

    # Filter out and iterate the valid compile entities
    compile_entities = filter(lambda x: x['file'] is not None, compile_entities)
    for ce in compile_entities:

      # Append the source file to the list (excluding combined sketch file)
      if not re.match(".+\.(pde|ino)\.cpp$", ce['file']):
        included_files.add(get_abs_path(ce['file']))

      # Retrive the including path of header
      # Filter out the include path from compiling arguments
      include_paths = list(filter(lambda x: re.match("^-I.+$", x), ce['arguments']))
      # Refine the list of files in the include path recursively
      include_paths = [get_header_list(include_path[2:]) for include_path in include_paths]
      # Append the files in the include path to the list
      included_files.update(list(itertools.chain(*include_paths)))
  
  # Discard useless path
  included_files.discard("")
  included_files.discard(None)

  # Chaining the included files
  included_files = '\n'.join(list(included_files))

  # Open the including file list in the safe way
  try:
    db_file = open(including_list_path, 'w+')
  except OSError:
      print(f"Could not open file: {including_list_path}\nPlease make sure the file is existed")
      sys.exit()

  # Write the included file list to file
  with db_file:
    db_file.write(included_files)

  print(f"Generating database of cscope to {cscope_database_path}")
  try:
    cscope = subprocess.run([
    "cscope",
    "-R", # Recursivly look up source file
    "-b", # Build cross-reference only
    "-U", # Update accroding to timestamp
    "-q", # Enable fast symbol lookup
    "-v", # Be more verbose
    "-k", # Do not use default include path
    "-i", # Specified source file list
    str(including_list_path),
  ], cwd=database_path, stderr=subprocess.PIPE)
    cscope.check_returncode()
  except subprocess.CalledProcessError as e:
    print ( "Error in executing cscope:\nreturn code: ", e.returncode, "\nOutput: ", e.stderr.decode("utf-8") )
    raise
  print()


  print(f"Generating database of ctags {ctags_database_path}")
  try:
    ctags = subprocess.run([
      "ctags",
      "-R",                          # Recursively look up source file
      "--verbose",                   # Print more information
      f"--langmap=c++:.cpp.ino.pde", # Mapping of Arduino sketch
      "-L",                          # Specified the list of source file
      str(including_list_path),
      "-f",                          # Specified the output file path
      str(ctags_database_path.name)
    ], cwd=database_path, stderr=subprocess.PIPE)
    ctags.check_returncode()
  except subprocess.CalledProcessError as e:
    print ( "Error in executing ctags:\nreturn code: ", e.returncode, "\nOutput: ", e.stderr.decode("utf-8") )
    raise

  print("\nAll done successfully\n")

if __name__ == "__main__":
  # Parse the command-line argument
  parser = argparse.ArgumentParser()
  parser.add_argument("-o", "--db-output", help="The base output folder related to your sketch directory. Default is the '.tags' folder in your sketch directory.", default=".tags")
  parser.add_argument("fqbn", help="The Fully Qualified Board Name (FQBN) of your target board. It can be obtained by command `arduino-cli board listall`. e.g.: arduino:avr:uno")
  parser.add_argument("sketch_path", help="The path to your Arduino sketch. Must contain at least one '.ino' file.")
  args = parser.parse_args()

  if not Path(args.sketch_path).is_dir():
    print(f"{args.sketch_path} is not a directory. Please check whether it had been existed.")
  else:
    main(args.fqbn, args.sketch_path, args.db_output)